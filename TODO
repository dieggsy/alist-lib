# -*- mode: org; -*
* TODO issues
  riastradh's claim about alist-backed hash-tables: we'd rather have
  transparency in certain circumstances; orthogonal to the
  alist-backed hash-table question (employed by scheme48, i believe he
  said).
* TODO =alist-set!=
  maybe the semantics of =alist-set!= can be equivalent to
  =set-car!= + =alist-cons=; leave updating to =alist-update!=? on the
  other hand, =vector-set!= semantics. hmm; let's follow srfi-69:
  =alist-set!= would indeed do a (possibly) destructive value update
  on a specific key irregardless of its previous value; it's like a
  blind =alist-update!=. relevant?

  in other words, =alist-set!= seems like a special case of
  =alist-update!=; or is it the other way around?

  #+BEGIN_SRC org
    ,- alist-set!
    ,  - case-lambda
    ,    - alist key value
    ,      - alist-set! alist key value eqv?
    ,    - alist key value =
    ,      - let
    ,        - pair assoc key alist =
    ,          - if value
    ,            - set-cdr! pair
    ,            - 
  #+END_SRC
  
  shit, how to deal with repeated keys here; we're not doing a
  hash-table, so theoretically repeated keys should be allowed. hmm;
  seems like we need a unique key policy.

  if we don't enforce unique keys, why not just =alist-cons= +
  =set-car!= (or whatever)? otherwise, if we do enforce unique keys
  (why?); =alist-delete!= will delete all such keys.

  why not have =alist-set!= set the first applicable key? that way, we
  can do a =set-cdr!=, etc.

  how does =set-car!= behave an on alist?

  #+BEGIN_SRC scheme
    (define (alist-prepend! alist key value)
      (let ((car (car alist)))
        (set-cdr! alist alist)
        (set-car! alist (cons key value))))
    
    (let ((alist '((1 . 2) (3 . 4))))
      (alist-prepend! alist 5 6)
      alist)
    
    #;
    (let ((alist '()))
      (alist-prepend! alist 5 6)
      alist)
  #+END_SRC
* DONE =alist-ref{,/default}=
  CLOSED: [2010-01-25 Mon 07:02]
  - CLOSING NOTE [2010-01-25 Mon 07:02] \\
    reasonable first pass
  srfi-1, srfi-16 and srfi-23 semantics

  #+BEGIN_SRC org
    ,- alist-ref 
    ,  - case-lambda
    ,    - alist key
    ,      - alist-ref alist key lambda error "key not found" key
    ,    - alist key thunk
    ,      - alist-ref alist key thunk eqv?
    ,    - alist key thunk =
    ,      - let
    ,        - value assoc key alist =
    ,          - or value (thunk)
  #+END_SRC

  how does alist-ref currently behave w.r.t. to unfound keys?

  #+BEGIN_SRC scheme
    (use test)
    (test
     "alist-ref on non-extant key"
     #f
     (alist-ref 'harro '((1 . 2))))
  #+END_SRC

  ah, returns #f; also, our parameter-order is incongruous with
  existing alist-ref and assoc; resembles srfi-69's ref.

  #+BEGIN_SRC scheme
    (use test)
    
    (define alist-ref
      (case-lambda
       ((alist key)
        (alist-ref alist key (lambda () (error "Key does not exist" key))))
       ((alist key thunk)
        (alist-ref alist key thunk eqv?))
       ((alist key thunk =)
        (let ((value (assoc key alist =)))
          (or (and value (cdr value))
              (thunk))))))
    
    (define alist-ref/default
      (case-lambda
       ((alist key default)
        (alist-ref alist key (lambda () default)))
       ((alist key default =)
        (alist-ref alist key (lambda () default) =))))
    
    (let ((alist '((1 . 2))))
      (test
       "alist-ref: extant key"
       2
       (alist-ref alist 1))
      (test-error
       "alist-ref: non-extant key, no default"
       (alist-ref alist 2))
      (test
       "alist-ref: non-extant key, thunk"
       3
       (alist-ref alist 2 (lambda () 3)))
      (test
       "alist-ref: =, thunk"
       3
       (alist-ref alist 1 (lambda () 3) (complement eqv?)))
      (test
       "alist-ref/default"
       2
       (alist-ref/default alist 1 3))
      (test
       "alist-ref/default: non-extant key"
       3
       (alist-ref/default alist 2 3))
      (test
       "alist-ref/default: default, ="
       3
       (alist-ref/default alist 1 3 (complement eqv?))))
  #+END_SRC
** leppie's rewrite
   http://paste.lisp.org/display/91332
* DONE scope
  CLOSED: [2010-01-25 Mon 07:02]
  - CLOSING NOTE [2010-01-25 Mon 07:02] \\
    defined
  really, i just want to standardize =alist-ref=; other interesting
  things: =alist-ref/default=, =alist-set!=, =alist-update!=,
  =alist-exists?=, =alist-update!{,default}=, =alist-keys=,
  =alist-values=, =alist-for-each= (dyadic), =alist-map=, =alist-fold=
  (dyadic), =alist-unfold= (maybe), =make-alist= (maybe),
  =tabulate-alist= (maybe), =alist-merge= (what would this do
  differently from =lset-union=? fuck it), etc.
* DONE [[http://srfi.schemers.org/srfi-69/srfi-69.html][srfi-69]]-based functions
  CLOSED: [2010-01-25 Mon 07:02]
  - CLOSING NOTE [2010-01-25 Mon 07:02] \\
    defining our scope
  - =alist?=
  - =alist-ref=
  - =alist-ref/default=
  - =alist-set!=
  - =alist-delete!=
  - =alist-exists?=
  - =alist-update!=
  - =alist-update!/default=
  - =alist-size=
  - =alist-keys=
  - =alist-values=
  - =alist-walk=
    #+BEGIN_QUOTE
    Note: in some implementations, there is a procedure called
    =hash-table-map= which does the same as this procedure. However,
    in other implementations, =hash-table-map= does something else. In
    no implementation that I know of, =hash-table-map= does a real
    functorial map that lifts an ordinary function to the domain of
    hash tables. Because of these reasons, =hash-table-map= is left
    outside this SRFI.
    #+END_QUOTE

    why not =alist-for-each= and =alist-map=? maybe we should consult
    [[http://srfi.schemers.org/srfi-43/srfi-43.html][vector-lib]], too.
  - =alist-fold=
  - =alist-copy=

    do we really need this? aren't there [[http://srfi.schemers.org/srfi-1/srfi-1.html#list-copy][=list-copy=]] mechanisms from srfi-1?
  - =alist-merge!=

    something along the lines of [[http://srfi.schemers.org/srfi-1/srfi-1.html#lset-union][=lset-union=]]?
* DONE [[http://srfi.schemers.org/srfi-43/srfi-43.html][srfi-43]]-based functions
  CLOSED: [2010-01-25 Mon 07:02]
  - CLOSING NOTE [2010-01-25 Mon 07:02] \\
    stick to srfi-69
  - =make-alist=
  - =alist-unfold=
  - =alist-unfold-right=
  - =alist-copy=

    just synonimize whatever srfi-1 equivalent
  - =alist-reverse-copy=
  - =alist-append=
  - =alist-concatenate=

    these things have srfi-1 equivalents
  - =alist?=

    should we divine list of lists?
  - =alist-empty?=

    =null?=
  - =alist==

    =equal?=
  - =alist-ref=
  - =alist-length=

    length
  - =alist-fold=
  - =alist-fold-right=
  - =alist-map=
  - =alist-map!=
  - =alist-for-each=
  - =alist-count=
  - =alist-index=
  - =alist-index-right=
  - =alist-skip=
  - =alist-skip-right=
  - =alist-binary-search=
  - =alist-any=

    could be a dyad?
  - =alist-every=

    v. supra: dyad?
  - =alist-set!=

    srfi-69 semantics are superior
  - =alist-swap!=

    relevant? not in srfi-1, for instance.
  - =alist-fill!=

    relevant? =make-list=, etc. look to srfi-1 for an =alist-tabulate=?
  - =alist-reverse!=

    srfi-1
  - =alist-copy!=

    interestingly, srfi-1 already has an [[http://srfi.schemers.org/srfi-1/srfi-1.html#alist-copy][=alist-copy=]]; in addition to
    =alist-cons=, =alist-delete=, =alist-delete!=. would be nice if we
    could restrict the scope to hash-table-like things.
  - =alist-reverse-copy!=

    not in srfi-1, for instance; relevant?
* DONE [[http://srfi.schemers.org/srfi-1/srfi-1.html#Miscellaneous][srfi-1]]-like functions
  CLOSED: [2010-01-25 Mon 07:01]
  - CLOSING NOTE [2010-01-25 Mon 07:02] \\
    stick to srfi-69
  - =alist-append=

    this is just append
  - =alist-zip=

    this is just zip? what about dyadism?
  - =alist-count=

    fuck it; let's limit the scope to srfi-69-like things. although,
    =append-maps= and =filter-maps= are cool.
  - =alist-remove=

    we already have =alist-delete=.
  - =alist-{every,any}=

    we already have =every=, =any=.
